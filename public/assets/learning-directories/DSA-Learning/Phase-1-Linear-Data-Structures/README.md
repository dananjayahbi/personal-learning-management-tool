# Phase 1: Linear Data Structures

## üéØ Phase Overview

Welcome to Phase 1! This is where your real DSA journey begins. Linear data structures are the foundation of computer science‚Äîthey organize data sequentially, making them intuitive to understand and essential for solving a wide variety of problems.

**Phase Duration:** 4-6 weeks  
**Difficulty Level:** Beginner to Intermediate  
**Prerequisites:** Completed Phase 0 (Foundations)

---

## üìã What You'll Learn

This phase covers the fundamental linear data structures:

1. **Arrays & Strings** - Contiguous memory storage and manipulation
2. **Linked Lists** - Dynamic node-based structures
3. **Stacks** - LIFO (Last In, First Out) operations
4. **Queues** - FIFO (First In, First Out) operations
5. **Hashing** - Fast lookups with hash tables
6. **Practice Problems** - Consolidation and mastery

---

## üìö Chapter Breakdown

### [Chapter 1: Arrays & Strings](./Chapter-1-Arrays-and-Strings/README.md)
**Duration:** 7-10 days  
**Problem Count:** 40+ problems

**Topics Covered:**
- Array Basics & Operations
- Multi-dimensional Arrays
- Dynamic Arrays (Vectors, ArrayLists)
- String Manipulation
- Two Pointer Technique
- Sliding Window Technique
- Kadane's Algorithm (Maximum Subarray)
- Array Rotation & Reversal
- Common Interview Patterns

**Why This Matters:**  
Arrays are the most fundamental data structure. They're used everywhere‚Äîin databases, image processing, machine learning, and more. Mastering arrays gives you a strong foundation for everything else.

**Key Algorithms:**
- Linear Search: O(n)
- Binary Search: O(log n)
- Kadane's Algorithm: O(n)
- Dutch National Flag: O(n)
- Boyer-Moore Voting: O(n)

**Learning Outcomes:**
- Manipulate arrays efficiently
- Apply two-pointer technique
- Use sliding window for subarray problems
- Optimize space complexity
- Solve string manipulation problems

---

### [Chapter 2: Linked Lists](./Chapter-2-Linked-Lists/README.md)
**Duration:** 6-8 days  
**Problem Count:** 30+ problems

**Topics Covered:**
- Singly Linked Lists
- Doubly Linked Lists
- Circular Linked Lists
- Implementation & Operations
- Two Pointer Technique for Linked Lists
- Fast & Slow Pointer (Floyd's Tortoise and Hare)
- Reversal Techniques
- Cycle Detection
- Common Interview Patterns

**Why This Matters:**  
Linked lists teach you about pointers, dynamic memory, and node-based thinking. They're essential for understanding more complex structures like trees and graphs.

**Key Algorithms:**
- Traversal: O(n)
- Insertion/Deletion: O(1) at known position
- Reverse: O(n)
- Cycle Detection (Floyd's): O(n) time, O(1) space
- Merge Two Sorted Lists: O(m+n)

**Learning Outcomes:**
- Implement linked lists from scratch
- Master pointer manipulation
- Detect and remove cycles
- Reverse linked lists (iterative and recursive)
- Merge and partition lists

---

### [Chapter 3: Stacks](./Chapter-3-Stacks/README.md)
**Duration:** 4-5 days  
**Problem Count:** 20+ problems

**Topics Covered:**
- Stack Fundamentals (LIFO principle)
- Array-based Implementation
- Linked List-based Implementation
- Applications of Stacks
- Expression Evaluation (Infix, Postfix, Prefix)
- Parentheses Matching
- Next Greater Element
- Stock Span Problem
- Monotonic Stack

**Why This Matters:**  
Stacks are everywhere‚Äîfrom function call management in programming languages to undo/redo functionality in applications. Understanding stacks helps you solve many algorithmic puzzles.

**Key Operations:**
- Push: O(1)
- Pop: O(1)
- Peek/Top: O(1)
- isEmpty: O(1)

**Learning Outcomes:**
- Implement stacks using arrays and linked lists
- Solve expression evaluation problems
- Apply monotonic stack pattern
- Use stacks for backtracking
- Recognize when to use stacks

---

### [Chapter 4: Queues](./Chapter-4-Queues/README.md)
**Duration:** 4-5 days  
**Problem Count:** 15+ problems

**Topics Covered:**
- Queue Fundamentals (FIFO principle)
- Array-based Implementation
- Linked List-based Implementation
- Circular Queue
- Deque (Double-ended Queue)
- Priority Queue Introduction
- Queue Applications
- Sliding Window Maximum

**Why This Matters:**  
Queues model real-world scenarios like waiting lines, task scheduling, and breadth-first search in graphs. They're fundamental for many algorithms you'll encounter later.

**Key Operations:**
- Enqueue: O(1)
- Dequeue: O(1)
- Front/Rear: O(1)
- isEmpty: O(1)

**Learning Outcomes:**
- Implement queues using arrays and linked lists
- Use circular queues efficiently
- Apply deques for specific problems
- Understand priority queues
- Solve queue-based puzzles

---

### [Chapter 5: Hashing](./Chapter-5-Hashing/README.md)
**Duration:** 5-7 days  
**Problem Count:** 35+ problems

**Topics Covered:**
- Hash Tables & Hash Maps
- Hash Functions
- Collision Resolution (Chaining, Open Addressing)
- Hash Sets
- Applications of Hashing
- Two Sum, Three Sum Problems
- Frequency Counting
- Subarray Sum Problems
- Longest Substring Problems

**Why This Matters:**  
Hashing provides O(1) average-case lookups, making it one of the most powerful techniques for optimization. Understanding hashing is crucial for interview success.

**Key Concepts:**
- Hash Function: Maps key to index
- Load Factor: n/m (elements/buckets)
- Collision Handling: Chaining, Linear Probing, Quadratic Probing
- Average Operations: O(1)
- Worst Case: O(n) when many collisions

**Learning Outcomes:**
- Design hash functions
- Handle collisions effectively
- Use hash maps for problem solving
- Optimize solutions using hashing
- Recognize hashing patterns

---

### [Chapter 6: Practice Problems](./Chapter-6-Practice-Problems/README.md)
**Duration:** 1-2 weeks  
**Problem Count:** 100+ curated problems

**Problem Categories:**
- **Easy (40 problems):** Build confidence
- **Medium (45 problems):** Challenge yourself
- **Hard (15 problems):** Push your limits

**Topics Covered:**
- All concepts from Chapters 1-5
- Mixed problem sets
- Pattern recognition
- Optimization challenges
- Interview-style questions

**Why This Matters:**  
Practice is what transforms knowledge into skill. This chapter consolidates everything you've learned and prepares you for real interviews.

**Problem Patterns:**
- Array manipulation
- Linked list operations
- Stack applications
- Queue problems
- Hash table usage
- Combined techniques

---

## üéØ Learning Path

### Week 1: Arrays & Strings (Part 1)
- Days 1-3: Array basics, operations, two-pointer
- Days 4-5: Sliding window technique
- Days 6-7: Practice 10-15 easy array problems

### Week 2: Arrays & Strings (Part 2)
- Days 1-3: String manipulation, pattern matching
- Days 4-5: Advanced array problems
- Days 6-7: Practice 15-20 medium array problems

### Week 3: Linked Lists
- Days 1-3: Singly linked list, operations
- Days 4-5: Two-pointer, cycle detection
- Days 6-7: Practice 15-20 linked list problems

### Week 4: Stacks & Queues
- Days 1-3: Stacks (implementation, applications)
- Days 4-5: Queues (implementation, applications)
- Days 6-7: Practice 15-20 stack/queue problems

### Week 5: Hashing
- Days 1-3: Hash tables, collision handling
- Days 4-5: Hash-based problem solving
- Days 6-7: Practice 20-25 hashing problems

### Week 6: Intensive Practice
- Complete all practice problems from Chapter 6
- Review weak areas
- Timed problem-solving sessions

---

## üõ†Ô∏è Implementation Guide

### Language-Specific Tips:

**Python:**
```python
# Lists are dynamic arrays
arr = [1, 2, 3]
# Dictionaries are hash maps
hashmap = {}
# Collections module for deque
from collections import deque
```

**C++:**
```cpp
// Vector for dynamic array
vector<int> arr;
// unordered_map for hash map
unordered_map<int, int> hashmap;
// queue and stack from STL
queue<int> q;
stack<int> st;
```

**Java:**
```java
// ArrayList for dynamic array
ArrayList<Integer> arr = new ArrayList<>();
// HashMap for hash map
HashMap<Integer, Integer> map = new HashMap<>();
// LinkedList for lists
LinkedList<Integer> list = new LinkedList<>();
```

---

## ‚úÖ Phase Completion Checklist

Before moving to Phase 2, ensure you can:

### Arrays & Strings:
- [ ] Implement dynamic array from scratch
- [ ] Apply two-pointer technique confidently
- [ ] Solve sliding window problems
- [ ] Reverse and rotate arrays
- [ ] Manipulate strings efficiently

### Linked Lists:
- [ ] Implement singly and doubly linked lists
- [ ] Reverse a linked list (iterative & recursive)
- [ ] Detect and remove cycles
- [ ] Merge two sorted lists
- [ ] Find middle of linked list

### Stacks & Queues:
- [ ] Implement stack using array and linked list
- [ ] Implement queue using array and linked list
- [ ] Evaluate postfix expressions
- [ ] Check balanced parentheses
- [ ] Implement min/max stack

### Hashing:
- [ ] Implement hash table with chaining
- [ ] Solve Two Sum using hash map
- [ ] Find duplicates using hashing
- [ ] Count frequencies
- [ ] Solve subarray sum problems

### General:
- [ ] Solved 100+ problems from this phase
- [ ] Can explain time/space complexity of solutions
- [ ] Recognize common patterns
- [ ] Code without looking at solutions
- [ ] Debug and optimize code

---

## üìä Progress Tracking

| Chapter | Topics | Problems Solved | Status |
|---------|--------|----------------|--------|
| Arrays & Strings | 9 topics | __/40 | ‚¨ú |
| Linked Lists | 9 topics | __/30 | ‚¨ú |
| Stacks | 9 topics | __/20 | ‚¨ú |
| Queues | 8 topics | __/15 | ‚¨ú |
| Hashing | 9 topics | __/35 | ‚¨ú |
| Practice | Mixed | __/100 | ‚¨ú |

---

## üéì Common Patterns & Templates

### Two Pointer:
```
left = 0, right = n-1
while left < right:
    if condition:
        # process
        left += 1
    else:
        right -= 1
```

### Sliding Window:
```
left = 0
for right in range(n):
    # add arr[right] to window
    while window_invalid:
        # remove arr[left] from window
        left += 1
    # update result
```

### Fast & Slow Pointer:
```
slow = head
fast = head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        # cycle detected
```

---

## üìö Recommended Resources

### Books:
- "Cracking the Coding Interview" (Chapters 1-4)
- "Elements of Programming Interviews" (Arrays, Linked Lists, Stacks, Queues)

### Online Courses:
- NeetCode: Arrays & Hashing, Linked Lists, Stacks
- freeCodeCamp: Data Structures (JavaScript)

### Practice Platforms:
- LeetCode: Explore Cards (Arrays, Linked Lists)
- HackerRank: Data Structures Track
- GeeksforGeeks: Linear Data Structures

### YouTube:
- Abdul Bari: Data Structures
- mycodeschool: Linked Lists, Stacks, Queues
- Back To Back SWE: Problem solving

---

## üöÄ What's Next?

After mastering Phase 1, you'll move to **Phase 2: Recursion & Backtracking**, where you'll learn:
- Recursive thinking
- Backtracking problems
- Divide and conquer strategies
- Tree recursion

**Tip:** Linear data structures appear everywhere in DSA. Master them thoroughly‚Äîthey're the foundation for trees, graphs, and advanced algorithms! üåü

---

[‚Üê Phase 0](../Phase-0-Foundations/README.md) | [Back to Main](../README.md) | [Next: Phase 2 ‚Üí](../Phase-2-Recursion-and-Backtracking/README.md)
